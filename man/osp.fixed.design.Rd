% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ospProbDesign.R
\name{osp.fixed.design}
\alias{osp.fixed.design}
\title{Generic dynamic emulation with a non-sequential design}
\usage{
osp.fixed.design(model, input.domain = NULL, method = "km",
  inTheMoney.thresh = 0, stop.freq = model$dt)
}
\arguments{
\item{input.domain:}{the domain of the emulator. Several options are available. Default in \code{NULL}
All the empirical domains rely on pilot paths generated using \code{pilot.nsims}>0 model parameter.
\itemize{
\item  NULL will use an empirical design (default);
\item if a vector of length 2*model$dim then specifies the bounding rectangle
\item a single positive number, then build a bounding rectangle based on the \eqn{\alpha}-quantile of the pilot paths
\item a single negative number, then build a bounding rectangle based on the full range of the pilot paths
\item a vector specifies the precise design, used as-is (\emph{overrides design size})
}}

\item{method:}{regression method to use (defaults to \code{km})
\itemize{
\item km: Gaussian process with fixed hyperparams  uses \pkg{DiceKriging} via \code{km} (default)
\item trainkm: GP w/trained hyperparams: use \pkg{DiceKriging} via \code{km}
\item lagp Local GP: use \pkg{laGP}
\item homgp Homoskedastic GP: use \pkg{hetGP} with  \code{mleHomGP}
\item hetgp Heteroskedastic GP: use \pkg{hetGP} with \code{mleHetGP}
\item spline: Smoothing Splines, use \code{smooth.spline}
\item loess: Local Regression: use \code{loess} with \code{lo.span} parameter
\item rvm: Relevance Vector Machine: use \pkg{kernlab} with \code{rvm}
\item lm: linear model from \pkg{stats}
}}

\item{inTheMoney.thresh:}{which paths are kept, out-of-the-money is dropped.
Defines threshold in terms of \code{model$payoff.func}}
}
\value{
a list containing:
\itemize{
\item \code{fit} a list containing all the models generated at each time-step. \code{fit[[1]]} is the emulator
at \eqn{t=\Delta t}, the last one is \code{fit[[M-1]]} which is emulator for \eqn{T-\Delta t}.
\item \code{val}: the in-sample pathwise rewards
\item \code{test}: the out-of-sample pathwise rewards
\item \code{p}: the final price (2-vector for in/out-of-sample)
\item \code{timeElapsed} (based on \code{Sys.time})
}
}
\description{
Batched non-adaptive design with a variety of regression methods
}
\details{
The design can be replicated through \code{batch.nrep} model parameter. Replication allows to use
nonparametric techniques which would be too expensive otherwise, in particular LOESS, GP and RVM.
All designs are restricted to in-the-money region, see \code{inTheMoney.thresh} parameter (modify at your own risk)
Thus, actual design size will be smaller than specified. By default, no forward evaluation is provided, ie the
method only builds the emulators. Thus, to obtain an actual estimate of the value
combine with \code{\link{forward.sim.policy}}
}
\examples{
set.seed(1)
model2d <- list( seq.design.size=100,look.ahead=1,init.size=100,
 ei.func='sur',cand.len=1000, batch.nrep=100,
 K=40,x0=rep(40,2),sigma=rep(0.2,2),r=0.06,div=0,
 T=1,dt=0.04,dim=2, sim.func=sim.gbm, payoff.func=put.payoff)
 bas22 <- function(x) return(cbind(x[,1],x[,1]^2,x[,2],x[,2]^2,x[,1]*x[,2]))
 model2d$bases <- bas22
 prob.lm <- osp.prob.design(30000,model2d,method="lm",subset=1:15000)
 prob.lm$price
}
