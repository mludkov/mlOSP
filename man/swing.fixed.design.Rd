% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ospProbDesign.R
\name{swing.fixed.design}
\alias{swing.fixed.design}
\title{Generic dynamic emulation of a multiple-stopping problem with a non-sequential design}
\usage{
swing.fixed.design(
  model,
  input.domain = NULL,
  method = "km",
  inTheMoney.thresh = 0
)
}
\arguments{
\item{model}{a list defining all the model parameters}

\item{input.domain}{the domain of the emulator. Several options are available. Default in \code{NULL}
All the empirical domains rely on pilot paths generated using \code{pilot.nsims}>0 model parameter.
\itemize{
\item NULL will use an empirical probabilistic design based on the pilot paths (default);
\item if a vector of length 2*model$dim then specifies the bounding rectangle
\item a single positive number, then build a bounding rectangle based on the \eqn{\alpha}-quantile of the pilot paths
\item a single negative number, then build a bounding rectangle based on the full range of the pilot paths
\item a vector specifies the precise design, used as-is (\emph{overrides design size})
}}

\item{method}{regression method to use (defaults to \code{km})
\itemize{
\item km: [(default] Gaussian process with fixed hyperparams  uses \pkg{DiceKriging} 
via \code{km}. Requires \code{km.cov} (vector of lengthscales)
and \code{km.var} (scalar process variance)  
\item trainkm: GP w/trained hyperparams: use \pkg{DiceKriging} via \code{km}. 
Requires to specify kernel family via \code{kernel.family}
\item mlegp Local GP from \pkg{laGP} (uses Gaussian squared exponential kernel)
\item homgp Homoskedastic GP: use \pkg{hetGP} with  \code{mleHomGP}. 
Requires to specify kernel family via \code{kernel.family}
\item hetgp Heteroskedastic GP: use \pkg{hetGP} with \code{mleHetGP}
Requires to specify kernel family via \code{kernel.family}
\item spline: Smoothing Splines, use \code{smooth.spline} from \pkg{base}  
with the user-specified \code{nk} number of knots (1D only)
\item cvspline: \code{smooth.spline} from \pkg{base} with automatically chosen 
 (via cross-validation) degrees of freedom/number of knots. Only works \emph{in 1D}
\item loess: Local polynomial regression: use \code{loess} with \code{lo.span} parameter
\item rvm: Relevance Vector Machine: use \pkg{kernlab} with \code{rvm}
\item lm: linear model from \pkg{stats} using \code{model$bases}
}}

\item{inTheMoney.thresh}{which paths are kept, out-of-the-money is dropped.
Defines threshold in terms of \code{model$payoff.func}}
}
\value{
a list containing:
\itemize{
\item \code{fit} a list containing all the models generated at each time-step. \code{fit[[1]]} is the emulator
at \eqn{t=\Delta t}, the last one is \code{fit[[M-1]]} which is emulator for \eqn{T-\Delta t}.
\item \code{val}: the in-sample pathwise rewards
\item \code{test}: the out-of-sample pathwise rewards
\item \code{p}: the final price (2-vector for in/out-of-sample)
\item \code{timeElapsed} (based on \code{Sys.time})
}
}
\description{
Swing option solver based on a batched non-adaptive design with a variety of regression methods
}
\details{
Solves for a swing with \code{n.swing} exercise rights. The payoff function is 
saved in \code{swing.payoff}. Also assumes a refraction period of \code{refract} between consecutive 
exercises. The experimental design is based on  \code{\link{osp.fixed.design}}. By default, no forward evaluation is provided, ie the
method only builds the emulators. Thus, to obtain an actual estimate of the value
combine with \code{\link{swing.policy}}.
}
\examples{
set.seed(1)
swingModel <- list(dim=1, sim.func=sim.gbm, x0=100,
swing.payoff=put.payoff, n.swing=3,K=100, 
sigma=0.3, r=0.05, div=0,
T=1,dt=0.02,refract=0.1,
N=800,pilot.nsims=1000,batch.nrep=25)
swingModel$nk=16  # number of knots for the smoothing spline
spl.swing <- swing.fixed.design(swingModel,input.domain=0.03, method ="spline")
}
